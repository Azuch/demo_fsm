
#include "http_transport.h"
#include "ca_certificate.h" // Generated by shell script

#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include <zephyr/net/net_event.h>
#include <zephyr/net/net_if.h>
#include <errno.h>
#include <string.h>

#include <zephyr/net/net_ip.h>
#include <zephyr/net/socket.h>
#include <zephyr/net/http/client.h>
#include <zephyr/net/tls_credentials.h>

#include <zephyr/posix/sys/socket.h>
#include <zephyr/posix/unistd.h>
#include <zephyr/posix/netdb.h>
#include <zephyr/posix/arpa/inet.h>

LOG_MODULE_REGISTER(HTTP_TRANSPORT, LOG_LEVEL_INF);

#define TLS_PEER_HOSTNAME "www.google.com"
#define HTTP_PORT "80"
#define HTTPS_PORT "443"

#define TLS_SEC_TAG 42

static uint8_t recv_buf[1024];

/* HTTP response callback */
static int response_cb(struct http_response *rsp,
		       enum http_final_call final_data,
		       void *user_data)
{
	if (final_data == HTTP_DATA_MORE) {
		LOG_INF("Partial data received (%zd bytes)", rsp->data_len);
	} else if (final_data == HTTP_DATA_FINAL) {
		LOG_INF("All the data received (%zd bytes)", rsp->data_len);
	}

	LOG_INF("Response status %s", rsp->http_status);

	return 0;
}


int http_transport_init(void)
{
	if (IS_ENABLED(CONFIG_NET_SOCKETS_SOCKOPT_TLS)) {
		int ret = tls_credential_add(TLS_SEC_TAG,
					     TLS_CREDENTIAL_CA_CERTIFICATE,
					     ca_certificate,
					     sizeof(ca_certificate));
		if (ret < 0) {
			LOG_ERR("Failed to register CA certificate: %d", ret);
			return ret;
		}
		LOG_INF("CA certificate registered.");
	}
	return 0;
}

int http_transport_send(const char *payload)
{
	int sock = -1;
	int ret;
	struct addrinfo *res;
	struct addrinfo hints;
	const char *port_str;

	bool use_tls = IS_ENABLED(CONFIG_NET_SOCKETS_SOCKOPT_TLS);

	if (use_tls) {
		port_str = HTTPS_PORT;
	} else {
		port_str = HTTP_PORT;
	}

	(void)memset(&hints, 0, sizeof(hints));

	if (IS_ENABLED(CONFIG_NET_IPV4)) {
		hints.ai_family = AF_INET;
	} else if (IS_ENABLED(CONFIG_NET_IPV6)) {
		hints.ai_family = AF_INET6;
	} else {
		hints.ai_family = AF_UNSPEC;
	}
	hints.ai_socktype = SOCK_STREAM;

	LOG_INF("Resolving hostname: %s", TLS_PEER_HOSTNAME);
	ret = getaddrinfo(TLS_PEER_HOSTNAME, port_str, &hints, &res);
	if (ret != 0) {
		LOG_ERR("getaddrinfo failed: %d", ret);
		return -EIO;
	}

	if (res == NULL) {
		LOG_ERR("Could not resolve hostname");
		return -ENOENT;
	}

	if (use_tls) {
		sec_tag_t sec_tag_list[] = {
			TLS_SEC_TAG,
		};
		sock = socket(res->ai_family, res->ai_socktype, IPPROTO_TLS_1_2);
		if (sock >= 0) {
			ret = setsockopt(sock, SOL_TLS, TLS_SEC_TAG_LIST,
					 sec_tag_list, sizeof(sec_tag_list));
			if (ret < 0) {
				LOG_ERR("Failed to set TLS_SEC_TAG_LIST option: %d", -errno);
				ret = -errno;
			}

			ret = setsockopt(sock, SOL_TLS, TLS_HOSTNAME,
					 TLS_PEER_HOSTNAME, sizeof(TLS_PEER_HOSTNAME));
			if (ret < 0) {
				LOG_ERR("Failed to set TLS_HOSTNAME option: %d", -errno);
				ret = -errno;
			}
		}
	} else {
		sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	}

	if (sock < 0) {
		LOG_ERR("Failed to create socket: %d", -errno);
		freeaddrinfo(res);
		return -errno;
	}

	LOG_INF("Connecting to server...");
	ret = connect(sock, res->ai_addr, res->ai_addrlen);
	if (ret < 0) {
		LOG_ERR("connect failed: %d", -errno);
		close(sock);
		freeaddrinfo(res);
		return -errno;
	}

	LOG_INF("Connected!");

	char host_with_port[256];
	snprintf(host_with_port, sizeof(host_with_port), "%s:%s", TLS_PEER_HOSTNAME, port_str);

	struct http_request req;
	memset(&req, 0, sizeof(req));

	req.method = HTTP_GET;
	req.url = "/";
	req.host = host_with_port;
	req.protocol = "HTTP/1.1";
	// The payload is ignored for GET requests, but we clear it for consistency
	req.payload = NULL;
	req.payload_len = 0;
	req.response = response_cb;
	req.recv_buf = recv_buf;
	req.recv_buf_len = sizeof(recv_buf);

	LOG_INF("Sending HTTP %s request...", http_method_str(req.method));
	ret = http_client_req(sock, &req, 5000, NULL);
	if (ret < 0) {
		LOG_ERR("http_client_req failed: %d", ret);
	} else {
		LOG_INF("HTTP request sent successfully.");
	}

	close(sock);
	freeaddrinfo(res);

	return ret;
}
